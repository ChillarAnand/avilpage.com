<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Avil Page (Posts about health-care)</title><link>http://avilpage.com/</link><description></description><atom:link href="http://avilpage.com/tags/health-care.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Mon, 30 Nov 2020 14:31:26 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>How To Deploy Mirth Connect To Kubernetes</title><link>http://avilpage.com/2020/07/deploy-mirth-to-kubernetes.html</link><dc:creator>Chillar Anand</dc:creator><description>&lt;div&gt;&lt;h4&gt;Introduction&lt;/h4&gt;
&lt;p&gt;NextGen Connect(previously Mirth Connect) is widely used integration engine for information exchange in health-care domain. In this article, let us see how to deploy Mirth Connect to a Kubernetes cluster.&lt;/p&gt;
&lt;h4&gt;Deployment To k8s&lt;/h4&gt;
&lt;p&gt;From version 3.8, NextGen has started providing official docker images for Connect&lt;sup id="fnref-nc"&gt;&lt;a class="footnote-ref" href="http://avilpage.com/2020/07/deploy-mirth-to-kubernetes.html#fn-nc"&gt;1&lt;/a&gt;&lt;/sup&gt;. By default, Connect docker exposes 8080, 8443 ports. We can start a Connect instance locally, by running the following command.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$docker&lt;/span&gt; run -p &lt;span class="m"&gt;8080&lt;/span&gt;:8080 -p &lt;span class="m"&gt;8443&lt;/span&gt;:8443 nextgenhealthcare/connect
&lt;/pre&gt;


&lt;p&gt;We can use this docker image and create a k8s deployment to start a container.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;---&lt;/span&gt;
&lt;span class="c"&gt;apiVersion: apps/v1beta1&lt;/span&gt;
&lt;span class="c"&gt;kind: Deployment&lt;/span&gt;
&lt;span class="c"&gt;metadata:&lt;/span&gt;
&lt;span class="c"&gt;  name: mirth-connect&lt;/span&gt;
&lt;span class="c"&gt;  namespace: default&lt;/span&gt;
&lt;span class="c"&gt;spec:&lt;/span&gt;
&lt;span class="c"&gt;  template:&lt;/span&gt;
&lt;span class="c"&gt;    spec:&lt;/span&gt;
&lt;span class="c"&gt;      containers:&lt;/span&gt;
&lt;span class="c"&gt;      - name: mirth-connect&lt;/span&gt;
&lt;span class="c"&gt;        image: docker.io/nextgenhealthcare/connect&lt;/span&gt;
&lt;span class="c"&gt;        ports:&lt;/span&gt;
&lt;span class="c"&gt;        - name: http&lt;/span&gt;
&lt;span class="c"&gt;          containerPort: 8080&lt;/span&gt;
&lt;span class="c"&gt;        - name: https&lt;/span&gt;
&lt;span class="c"&gt;          containerPort: 8443&lt;/span&gt;
&lt;span class="c"&gt;        - name: hl7-test&lt;/span&gt;
&lt;span class="c"&gt;          containerPort: 9001&lt;/span&gt;
&lt;span class="c"&gt;        env:&lt;/span&gt;
&lt;span class="c"&gt;          - name: DATABASE&lt;/span&gt;
&lt;span class="c"&gt;            value: postgres&lt;/span&gt;
&lt;span class="c"&gt;          - name: DATABASE_URL&lt;/span&gt;
&lt;span class="c"&gt;            value: jdbc:postgresql://avilpage.com:5432/mirth_db&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This deployment file can be applied on a cluster using &lt;code&gt;kubectl&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ kubectl apply -f connect-deployment.yaml
&lt;/pre&gt;


&lt;p&gt;To access this container, we can create a service to expose this deployment to public.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;---&lt;/span&gt;
&lt;span class="c"&gt;apiVersion: v1&lt;/span&gt;
&lt;span class="c"&gt;kind: Service&lt;/span&gt;
&lt;span class="c"&gt;metadata:&lt;/span&gt;
&lt;span class="c"&gt;  name: mirth-connect&lt;/span&gt;
&lt;span class="c"&gt;  annotations:&lt;/span&gt;
&lt;span class="c"&gt;    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:ap-south-1:foo&lt;/span&gt;
&lt;span class="c"&gt;    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"&lt;/span&gt;
&lt;span class="c"&gt;    external-dns.alpha.kubernetes.io/hostname: connect.avilpage.com&lt;/span&gt;
&lt;span class="c"&gt;spec:&lt;/span&gt;
&lt;span class="c"&gt;  type: LoadBalancer&lt;/span&gt;
&lt;span class="c"&gt;  selector:&lt;/span&gt;
&lt;span class="c"&gt;    app: mirth-connect&lt;/span&gt;
&lt;span class="c"&gt;  ports:&lt;/span&gt;
&lt;span class="c"&gt;    - name: http&lt;/span&gt;
&lt;span class="c"&gt;      port: 80&lt;/span&gt;
&lt;span class="c"&gt;      targetPort: 8080&lt;/span&gt;
&lt;span class="c"&gt;      protocol: TCP&lt;/span&gt;
&lt;span class="c"&gt;    - name: https&lt;/span&gt;
&lt;span class="c"&gt;      port: 443&lt;/span&gt;
&lt;span class="c"&gt;      targetPort: 8443&lt;/span&gt;
&lt;span class="c"&gt;      protocol: TCP&lt;/span&gt;
&lt;span class="c"&gt;    - name: hl7-test&lt;/span&gt;
&lt;span class="c"&gt;      port: 9001&lt;/span&gt;
&lt;span class="c"&gt;      targetPort: 9001&lt;/span&gt;
&lt;span class="c"&gt;      protocol: TCP&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will create a load balancer in AWS through which we can access mirth connect instance. If an ingress controller is present in the cluster, we can use it directly instead of using a seperate load balancer for this service.&lt;/p&gt;
&lt;p&gt;Once Mirth Connect is up &amp;amp; running, we might have to create HL7 channels running on various ports. In the above configuration files, we have exposed 9001 HL7 port for testing of channel. Once we configure Mirth Channels, we need to expose appropriate ports in deployment as well as service similiar to this.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;Earlier, there were no official docker images for Mirth Connect and it was bit diffucult to dockerize Mirth Connect and deploy it. With the release of official Docker images, deploying Mirth Connect to k8s or any other container orchestration platform has become much easier.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn-nc"&gt;
&lt;p&gt;&lt;a href="https://hub.docker.com/r/nextgenhealthcare/connect/"&gt;https://hub.docker.com/r/nextgenhealthcare/connect/&lt;/a&gt; &lt;a class="footnote-backref" href="http://avilpage.com/2020/07/deploy-mirth-to-kubernetes.html#fnref-nc" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>devops</category><category>health-care</category><category>kubernetes</category><category>mirth-connect</category><guid>http://avilpage.com/2020/07/deploy-mirth-to-kubernetes.html</guid><pubDate>Wed, 30 Sep 2020 17:55:46 GMT</pubDate></item><item><title>Mastering DICOM - Part #1</title><link>http://avilpage.com/2019/12/mastering-dicom-part-1.html</link><dc:creator>Chillar Anand</dc:creator><description>&lt;div&gt;&lt;h4&gt;Introduction&lt;/h4&gt;
&lt;p&gt;In hospitals, &lt;a href="https://en.wikipedia.org/wiki/Picture_archiving_and_communication_system"&gt;PACS&lt;/a&gt; simplifies the clinical workflow by reducing physical and time barriers. A typical radiology workflow looks like this.&lt;/p&gt;
&lt;p algin="center"&gt;
&lt;img src="http://avilpage.com/images/dicom-pacs-python1.png"&gt;
&lt;/p&gt;

&lt;p&gt;Credit: &lt;cite&gt;Wikipedia&lt;/cite&gt;&lt;/p&gt;

&lt;p&gt;A patient as per doctor's request will visit a radiology center to undergo CT/MRI/X-RAY. Data captured from modality(medical imaging equipments like CT/MRI machine) will be sent to QA for verfication and then sent to PACS for archiving.&lt;/p&gt;
&lt;p&gt;After this when patient visits doctor, doctor can see this study on his workstation(which has DICOM viewer) by entering patient details.&lt;/p&gt;
&lt;p&gt;In this series of articles, we will how to achieve this seamless transfer of medical data digitally with DICOM.&lt;/p&gt;
&lt;h4&gt;DICOM standard&lt;/h4&gt;
&lt;p&gt;DICOM modalities create files in DICOM format. This file has dicom header which contains meta data and dicom data set which has modality info(equipment information, equipment configuration etc), patient information(name, sex etc) and the image data.&lt;/p&gt;
&lt;p&gt;Storing and retreiving DICOM files from PACS servers is generally achieved through DIMSE DICOM for desktop applications and DICOMWeb for web applications.&lt;/p&gt;
&lt;p&gt;All the machines which transfer/receive DICOM data must follow DICOM standard. With this all the DICOM machines which are in a network can store and retrieve DICOM files from PACS.&lt;/p&gt;
&lt;p&gt;When writing software to handle DICOM data, there are third party packages to handle most of the these things for us.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Python(&lt;a href="https://pypi.org/project/pydicom/"&gt;pydicom&lt;/a&gt;, &lt;a href="https://pypi.org/project/pynetdicom/"&gt;pynetdicom&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ruby (&lt;a href="https://rubygems.org/gems/dicom/"&gt;ruby-dicom&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;R (&lt;a href="https://CRAN.R-project.org/package=oro.dicom"&gt;oro.dicom&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C/C++ (&lt;a href="https://dicom.offis.de/dcmtk"&gt;dcmtoolkit&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;In this article, we have learnt the clinical radiology workflow and how DICOM standard is useful in digitally transferring data between DICOM modalities.&lt;/p&gt;
&lt;p&gt;In the next article, we will dig into DICOM file formats and learn about the structure of DICOM data.&lt;/p&gt;&lt;/div&gt;</description><category>health-care</category><category>python</category><guid>http://avilpage.com/2019/12/mastering-dicom-part-1.html</guid><pubDate>Tue, 31 Dec 2019 13:29:09 GMT</pubDate></item></channel></rss>