<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Avil Page (Posts about kubernetes)</title><link>http://avilpage.com/</link><description></description><atom:link href="http://avilpage.com/tags/kubernetes.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Fri, 02 Oct 2020 13:41:17 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>How To Deploy Mirth Connect To Kubernetes</title><link>http://avilpage.com/2020/07/deploy-mirth-to-kubernetes.html</link><dc:creator>Chillar Anand</dc:creator><description>&lt;div&gt;&lt;h4&gt;Introduction&lt;/h4&gt;
&lt;p&gt;NextGen Connect(previously Mirth Connect) is widely used integration engine for information exchange in health-care domain. In this article, let us see how to deploy Mirth Connect to a Kubernetes cluster.&lt;/p&gt;
&lt;h4&gt;Deployment To k8s&lt;/h4&gt;
&lt;p&gt;From version 3.8, NextGen has started providing official docker images for Connect&lt;sup id="fnref-nc"&gt;&lt;a class="footnote-ref" href="http://avilpage.com/2020/07/deploy-mirth-to-kubernetes.html#fn-nc"&gt;1&lt;/a&gt;&lt;/sup&gt;. By default, Connect docker exposes 8080, 8443 ports. We can start a Connect instance locally, by running the following command.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$docker&lt;/span&gt; run -p &lt;span class="m"&gt;8080&lt;/span&gt;:8080 -p &lt;span class="m"&gt;8443&lt;/span&gt;:8443 nextgenhealthcare/connect
&lt;/pre&gt;


&lt;p&gt;We can use this docker image and create a k8s deployment to start a container.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;---&lt;/span&gt;
&lt;span class="c"&gt;apiVersion: apps/v1beta1&lt;/span&gt;
&lt;span class="c"&gt;kind: Deployment&lt;/span&gt;
&lt;span class="c"&gt;metadata:&lt;/span&gt;
&lt;span class="c"&gt;  name: mirth-connect&lt;/span&gt;
&lt;span class="c"&gt;  namespace: default&lt;/span&gt;
&lt;span class="c"&gt;spec:&lt;/span&gt;
&lt;span class="c"&gt;  template:&lt;/span&gt;
&lt;span class="c"&gt;    spec:&lt;/span&gt;
&lt;span class="c"&gt;      containers:&lt;/span&gt;
&lt;span class="c"&gt;      - name: mirth-connect&lt;/span&gt;
&lt;span class="c"&gt;        image: docker.io/nextgenhealthcare/connect&lt;/span&gt;
&lt;span class="c"&gt;        ports:&lt;/span&gt;
&lt;span class="c"&gt;        - name: http&lt;/span&gt;
&lt;span class="c"&gt;          containerPort: 8080&lt;/span&gt;
&lt;span class="c"&gt;        - name: https&lt;/span&gt;
&lt;span class="c"&gt;          containerPort: 8443&lt;/span&gt;
&lt;span class="c"&gt;        - name: hl7-test&lt;/span&gt;
&lt;span class="c"&gt;          containerPort: 9001&lt;/span&gt;
&lt;span class="c"&gt;        env:&lt;/span&gt;
&lt;span class="c"&gt;          - name: DATABASE&lt;/span&gt;
&lt;span class="c"&gt;            value: postgres&lt;/span&gt;
&lt;span class="c"&gt;          - name: DATABASE_URL&lt;/span&gt;
&lt;span class="c"&gt;            value: jdbc:postgresql://avilpage.com:5432/mirth_db&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This deployment file can be applied on a cluster using &lt;code&gt;kubectl&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ kubectl apply -f connect-deployment.yaml
&lt;/pre&gt;


&lt;p&gt;To access this container, we can create a service to expose this deployment to public.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;---&lt;/span&gt;
&lt;span class="c"&gt;apiVersion: v1&lt;/span&gt;
&lt;span class="c"&gt;kind: Service&lt;/span&gt;
&lt;span class="c"&gt;metadata:&lt;/span&gt;
&lt;span class="c"&gt;  name: mirth-connect&lt;/span&gt;
&lt;span class="c"&gt;  annotations:&lt;/span&gt;
&lt;span class="c"&gt;    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:ap-south-1:foo&lt;/span&gt;
&lt;span class="c"&gt;    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"&lt;/span&gt;
&lt;span class="c"&gt;    external-dns.alpha.kubernetes.io/hostname: connect.avilpage.com&lt;/span&gt;
&lt;span class="c"&gt;spec:&lt;/span&gt;
&lt;span class="c"&gt;  type: LoadBalancer&lt;/span&gt;
&lt;span class="c"&gt;  selector:&lt;/span&gt;
&lt;span class="c"&gt;    app: mirth-connect&lt;/span&gt;
&lt;span class="c"&gt;  ports:&lt;/span&gt;
&lt;span class="c"&gt;    - name: http&lt;/span&gt;
&lt;span class="c"&gt;      port: 80&lt;/span&gt;
&lt;span class="c"&gt;      targetPort: 8080&lt;/span&gt;
&lt;span class="c"&gt;      protocol: TCP&lt;/span&gt;
&lt;span class="c"&gt;    - name: https&lt;/span&gt;
&lt;span class="c"&gt;      port: 443&lt;/span&gt;
&lt;span class="c"&gt;      targetPort: 8443&lt;/span&gt;
&lt;span class="c"&gt;      protocol: TCP&lt;/span&gt;
&lt;span class="c"&gt;    - name: hl7-test&lt;/span&gt;
&lt;span class="c"&gt;      port: 9001&lt;/span&gt;
&lt;span class="c"&gt;      targetPort: 9001&lt;/span&gt;
&lt;span class="c"&gt;      protocol: TCP&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will create a load balancer in AWS through which we can access mirth connect instance. If an ingress controller is present in the cluster, we can use it directly instead of using a seperate load balancer for this service.&lt;/p&gt;
&lt;p&gt;Once Mirth Connect is up &amp;amp; running, we might have to create HL7 channels running on various ports. In the above configuration files, we have exposed 9001 HL7 port for testing of channel. Once we configure Mirth Channels, we need to expose appropriate ports in deployment as well as service similiar to this.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;Earlier, there were no official docker images for Mirth Connect and it was bit diffucult to dockerize Mirth Connect and deploy it. With the release of official Docker images, deploying Mirth Connect to k8s or any other container orchestration platform has become much easier.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn-nc"&gt;
&lt;p&gt;&lt;a href="https://hub.docker.com/r/nextgenhealthcare/connect/"&gt;https://hub.docker.com/r/nextgenhealthcare/connect/&lt;/a&gt; &lt;a class="footnote-backref" href="http://avilpage.com/2020/07/deploy-mirth-to-kubernetes.html#fnref-nc" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>devops</category><category>health-care</category><category>kubernetes</category><category>mirth-connect</category><guid>http://avilpage.com/2020/07/deploy-mirth-to-kubernetes.html</guid><pubDate>Wed, 30 Sep 2020 17:55:46 GMT</pubDate></item><item><title>Continuous Deployment To Kubernetes With Skaffold</title><link>http://avilpage.com/2020/04/setup-continuous-deployment-with-kubernetes.html</link><dc:creator>Chillar Anand</dc:creator><description>&lt;div&gt;&lt;p&gt;In this article, let us see how to setup a continuous deployment pipeline to Kubernetes in CircleCI using Skaffold.&lt;/p&gt;
&lt;h4&gt;Prerequisites&lt;/h4&gt;
&lt;p&gt;You should have a kubernetes cluster in a cloud environment or in your local machine. Check your cluster status with the following commands.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ kubectl cluster-info
$ kubectl config get-contexts
&lt;/pre&gt;


&lt;p&gt;You should know how to manually deploy your application to kubernetes.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# push latest docker image to container registry&lt;/span&gt;
$ docker push chillaranand/library

&lt;span class="c1"&gt;# deploy latest image to k8s&lt;/span&gt;
$ kubectl apply -f app/deployment.yaml
$ kubectl apply -f app/service.yaml
&lt;/pre&gt;


&lt;h4&gt;Skaffold&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/GoogleContainerTools/skaffold"&gt;Skaffold&lt;/a&gt; is a CLI tool to facilitate continuous development and deployment workflows for Kubernetes applications.&lt;/p&gt;
&lt;p&gt;Skaffold binaries are available for all platforms. Download the binary file for your OS and move it to bin folder.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-amd64
$ chmod +x skaffold
$ sudo mv skaffold /usr/local/bin
&lt;/pre&gt;


&lt;p&gt;Inside your project root, run &lt;code&gt;init&lt;/code&gt; command to generate a config file. If your project has k8s manifests, it will detect them and include it in the configuration file.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ skaffold init
Configuration skaffold.yaml was written

$ cat skaffold.yaml
apiVersion: skaffold/v2beta1
kind: Config
metadata:
  name: library
build:
  artifacts:
  - image: docker.io/chillaranand/library
deploy:
  kubectl:
    manifests:
    - kubernetes/deployment.yaml
    - kubernetes/service.yaml
&lt;/pre&gt;


&lt;p&gt;To deploy latest changes to your cluster, run&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ skaffold run
&lt;/pre&gt;


&lt;p&gt;This will build the docker image, push to registry and will apply the manifests in the clusters. Now, k8s will pull the latest image from the registry and create a new deployment.&lt;/p&gt;
&lt;h4&gt;CircleCI Workflow&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;version: &lt;span class="m"&gt;2&lt;/span&gt;.1

orbs:
  aws-cli: circleci/aws-cli@0.1.19
  kubernetes: circleci/kubernetes@0.11.0

commands:
  kubernetes-deploy:

    steps:
      - setup_remote_docker

      - aws-cli/setup:
          profile-name: default

      - kubernetes/install-kubectl:
          kubectl-version: v1.15.10

      - checkout

      - run:
          name: container registry log in
          command: &lt;span class="p"&gt;|&lt;/span&gt;
            sudo &lt;span class="k"&gt;$(&lt;/span&gt;aws ecr get-login --region ap-south-1 --no-include-email&lt;span class="k"&gt;)&lt;/span&gt;

      - run:
          name: install skaffold
          command: &lt;span class="p"&gt;|&lt;/span&gt;
            curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64
            chmod +x skaffold
            sudo mv skaffold /usr/local/bin

      - run:
          name: update kube config to connect to the required cluster
          command: &lt;span class="p"&gt;|&lt;/span&gt;
            aws eks --region ap-south-1 update-kubeconfig --name demo-cluster

      - run:
          name: deploy to k8s
          command: &lt;span class="p"&gt;|&lt;/span&gt;
            skaffold run
&lt;/pre&gt;


&lt;p&gt;CircleCI orbs are shareable packages to speed up CI setup. Here we are using aws-cli, kubernetes orbs to easily install/setup them inside the CI environment.&lt;/p&gt;
&lt;p&gt;Since CircleCI builds run in a docker container, to run docker commands inside container, we have to specify &lt;code&gt;setup_remote_docker&lt;/code&gt; key so that a seperate environment is created for it.&lt;/p&gt;
&lt;p&gt;Remaining steps are self explainatory.&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;Here we have seen how to setup CD to kubernetes in CircleCI. If we want to setup this another CI like Jenkins or Travis, instead of using orbs, we have to use system package mangers like apt-get to install them. All others steps will remain same.&lt;/p&gt;&lt;/div&gt;</description><category>devops</category><category>kubernetes</category><guid>http://avilpage.com/2020/04/setup-continuous-deployment-with-kubernetes.html</guid><pubDate>Thu, 30 Apr 2020 11:15:36 GMT</pubDate></item></channel></rss>